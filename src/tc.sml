(* The compiler from expression to rp *)
structure TC =
struct

(*

The next three lines show how to interconnect the parser (generated my
ml-yacc) with the lexer (generated by ml-lex).

￼
￼
￼
￼

1. Use the `TigerLrValsFun` functor to create an `TigerLrVals`
   structure.  The `TigerLrVals` thus created has manythings required
   by the parser like the parsing table. It also has the Tokens data
   type of the language and the lexer needs to know this.

2. The substructure `TigerLrVals.Tokens` is then passed to the lexer
   generator functor `TigerLexFun` to get the lexer structure `TigerLex`

3. Finally, the lexer (available in `TigerLex`) is combined with the
   parsing data to build the parser. Note that the parser needs to
   know the lexing function as it is used by the parser to get tokens.

NOTE: The names of the structures are all controllable. For example
our functors are called TigerLrValsFun and TigerLexFun due to the line
starting with `%name` in expr.grm and `%header` line in the expr.lex
respectively.

*)

structure TigerLrVals = TigerLrValsFun(structure Token = LrParser.Token)
structure TigerLex    = TigerLexFun(structure Tokens = TigerLrVals.Tokens)
structure TigerParser = Join( structure ParserData = TigerLrVals.ParserData
			     structure Lex        = TigerLex
			     structure LrParser   = LrParser
			   )

(* 

At this point every thing regarding lexing and parsing is contained in
the TigerParser structure. Let us create a lexer using this.

*)
(* Build Lexers *)
fun makeTigerLexer strm = TigerParser.makeLexer (fn n => TextIO.inputN(strm,n))
val makeFileLexer      = makeTigerLexer o TextIO.openIn


(* Parse command line and set a suitable lexer *)

val thisLexer = case CommandLine.arguments() of
		    []  => makeTigerLexer TextIO.stdIn
		 |  [x] => makeFileLexer x
		 |  _   => (TextIO.output(TextIO.stdErr, "usage: tc file"); OS.Process.exit OS.Process.failure)



fun print_error (s,i:int,_) = TextIO.output(TextIO.stdErr,
					    "Error, line " ^ (Int.toString i) ^ ", " ^ s ^ "\n")

val (program,_) = TigerParser.parse (0,thisLexer,print_error,()) (* parsing *)
val executable  = 	[MIPS.Text, MIPS.Global("main"),MIPS.LabelStmt(MIPS.UserDefined("main"))] 
					@ (TRANSLATE.compile program) 
					@ [MIPS.Instr(MIPS.Li(MIPS.V(0),10)),MIPS.Instr(MIPS.Syscall)] (* compiling/code generation *)
val exec_str 	= IR.pp(executable)
val _           = TextIO.output(TextIO.stdOut, exec_str)
			       (* writing out the executable (in this case rp expression ) *)

end
